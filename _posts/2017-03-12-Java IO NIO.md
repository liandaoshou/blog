---
layout: post
title:  "Java IO/NIO"
date:   2017-03-12 10:07:03 +0800
categories: Java JVM IO NIO
tag: Java
---

# JAVA IO 

## 阻塞IO模型

最传统的IO模型，在读写数据过程中会发生阻塞现象。当用户线程发出IO请求后，内核会查看数据是否就绪，如果没有就绪就会等待数据就绪，
而用户线程处于阻塞状态，用户线程交出CPU。当数据就绪后， 内核将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。
典型的IO阻塞模型例子：data = socket.read();如果数据没有就绪就会一直组晒在read。

## 非阻塞IO模型

当用户线程发起一个read操作后，并不需要等待，马上就得到一个结果。如果结果是一个error时，数据还未准备好，可以再次发送read操作。
一旦数据准备好。并且再次收到用户线程请求，会将数据拷贝到用户线程，然后返回。
非阻塞IO模型中，用户线程需要不断询问内核数据是否就绪，也就是说非阻塞IO不会交出CPU，而是会一直占用CPU。
典型的非阻塞IO模型一般如下：
```
while(true) {
    data = socket.read();
    if (data != error) {
        // 处理数据
        break;
    }
}
```
对于非阻塞IO有一个非常严重的问题，不断询问内核数据是否就绪，导致CPU占用率非常高，一般情况下很少使用while循环读取数据。

## 多路复用IO模型

多路复用IO模型时目前使用比较多的模型。Java NIO实际生就是多路复用IO。在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，
当socket真正有读写时间时，才真的调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以关联多个socket，系统不需要建立新的进程或线程。
也不必维护这些线程进程，并且只有真正的读写事件进行时，才会使用IO资源，减少了资源的占用。
多路复用IO适合连接数比较多的情况。

另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态
时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效
率要比用户线程要高的多。

不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件
逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件
迟迟得不到处理，并且会影响新的事件轮询。

## 信号驱动IO模型

在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行。
当内核数据就绪会发送一个信号给用户线程，用户线程接收到后，便在信号函数中调用IO读写操作来进行事件IO请求操作。

## 异步IO模型

异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作后，立即就开始做其他事情，从内核角度出发，当他收到一个asynchronous read之后，
它会立即返回，说明read请求发起成功，因此不会对用户线程产生任何block。然后内核就会等待数据准备完成，将数据拷贝到用户线程，当一切完成以后，内核会给用户线程发一个信号，
read操作完成了，此时用户线程只需要发起请求，接收内核的返回。

也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完
成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的
读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据
已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号
表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。
注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。

# JAVA NIO

NIO 主要有三大核心：channel（通道），buffer（缓冲区），selector（选择区）。传统IO基于字节流和字符流进行操作，而NIO基于channel和buffer操作，
数据总是从通道读取到缓冲区，或者从缓冲区写到通道中。
selector用于监听多个通道事件，单个线程可以监听多个数据通道。

NIO和IO最大区别是：IO是面向流的，NIO是面向通道的。

##  NIO的缓冲区

Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何
地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓
存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在
缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所
有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的
数据。

## NIO的非阻塞

IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有
一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，
使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可
用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以
继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它
完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上
执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

## channel

Channel 和 IO 中的 Stream(流)是差不多一个
等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向
的，既可以用来进行读操作，又可以用来进行写操作。
NIO 中的 Channel 的主要实现有：
1. FileChannel
2. DatagramChannel
3. SocketChannel
4. ServerSocketChannel
这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。
下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的

## buffer

![buffer](/images/posts/20170312/01.png)<br>

Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、
网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。

上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送
数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必
须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。
在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：
ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、
ShortBuffer

## selector

Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事
件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可
以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用
函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护
多个线程，并且避免了多线程之间的上下文切换导致的开销。