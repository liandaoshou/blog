---
layout: post
title:  "Java IO/NIO"
date:   2017-03-12 10:07:03 +0800
categories: Java JVM IO NIO
tag: Java
---

## 阻塞IO模型

最传统的IO模型，在读写数据过程中会发生阻塞现象。当用户线程发出IO请求后，内核会查看数据是否就绪，如果没有就绪就会等待数据就绪，
而用户线程处于阻塞状态，用户线程交出CPU。当数据就绪后， 内核将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。
典型的IO阻塞模型例子：data = socket.read();如果数据没有就绪就会一直组晒在read。

## 非阻塞IO模型

当用户线程发起一个read操作后，并不需要等待，马上就得到一个结果。如果结果是一个error时，数据还未准备好，可以再次发送read操作。
一旦数据准备好。并且再次收到用户线程请求，会将数据拷贝到用户线程，然后返回。
非阻塞IO模型中，用户线程需要不断询问内核数据是否就绪，也就是说非阻塞IO不会交出CPU，而是会一直占用CPU。
典型的非阻塞IO模型一般如下：
```
while(true) {
    data = socket.read();
    if (data != error) {
        // 处理数据
        break;
    }
}
```
对于非阻塞IO有一个非常严重的问题，不断询问内核数据是否就绪，导致CPU占用率非常高，一般情况下很少使用while循环读取数据。

## 多路复用IO模型

