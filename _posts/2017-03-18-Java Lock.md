---
layout: post
title:  "Java 锁"
date:   2017-03-18 11:20:12 +0800
categories: Java Lock
tag: Java
---

## Java 锁

### 乐观锁

乐观锁是一种乐观思想，认为读多写少，遇到并发的可能低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下此期间别人是否更新过这个数据，采取在写的时候先读取当时的版本号然后加锁锁操作，
如果失败则要重复读-比较-写的操作。

### 悲观锁

悲观锁就是悲观思想，认为写多，遇到并发写的可能性比较高，每次去拿数据的时候都认为别人会修改，所以在读写数据的时候都会上锁，这样别人想读写这个数据的似乎就会block直到拿到锁。
Java中的悲观锁就是Synchronized，AQS框架下的锁是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock（可重入锁）。

### 自旋锁

如果持有锁的线程能在很短时间内释放锁资源，那么等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，他们只需要等一等（自旋），等待有锁的线程释放锁后即可立即获得锁，这样就避免用户线程和内核的切换消耗。

线程自旋是需要消耗cpu的，就是让cpu在做无用功，如果一直获取不到锁，那线程也不能一直占用cpu自旋做无用功，所以需要设定一个自旋等待的最大时间。

如果持有锁的线程执行时间超过自旋等待的最大时间仍然没有释放锁，就会导致其他争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程就会停止自旋进入阻塞状态。

自旋锁的优缺点：

自旋锁尽可能减少线程的阻塞，对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作消耗，这些操作会导致线程发生两次上下文切换。
如果锁的竞争记录，或者持有锁线程需要长时间占用锁执行同步块，这时候就不适合使用自旋，因为自旋获取锁一直都再占用cpu做无用功，同时有大量的线程在竞争一个锁，会导致获取锁的时间很长，
线程自旋的消耗大于线程阻塞挂起操作的消耗，其他需要cpu的线程又不能获取，造成资源浪费，这种情况下要关闭自旋锁。

自旋锁的时间阈值（JDK1.6引入了适应性自旋锁）

自旋锁的目的是为了占着CPU资源不释放，等获取到锁立即处理，如何去选择自旋时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用cpu资源，影响整体系统的性能，因此自旋周期格外重要。
JVM对于自旋周期的选择，JDK1.5这个限度时写死的，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，
基本认为一个线程上下文切换的时间时最佳的一个时间，同时JVM还针对当前CPU的负荷情况做了较多的优化，如果平均负载小于CPUs则一直自旋，如果超过（CPUs/2）个线程正在自旋，则后来线程直接阻塞，
如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果CPU处于节电模式则停止自旋，自旋时间最坏情况时CPU的存储延迟，自旋时会适当放弃线程优先级之间的差异。

自旋锁的开启

JDK1.6中 -XX：+ UseSprinning开启；
-XX：PreBlockSpin=10 为自旋次数；
JDK1.7后，去除此参数，由JVM控制；


### 同步锁 （Synchronized）

Synchronized可以把任意一个非Null的对象当作锁，属于独占式的悲观锁，同时属于可重入锁。

- Synchronized作用范围

1. 作用方法时，锁住的对象的实例（this）
2. 当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久代PermGen（JDK1.8是metaspace），永久代是全局共享的，因此静态方法锁相当于类的一个全局锁，
会锁所有调用该方法的线程。
3. synchronized作用于对象实例时，所著的时所有以该对象为锁的代码块，它又多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同容器中。

- Synchronized核心组件

1) Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；
2) Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；
3) Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；
4) OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；
5) Owner：当前已经获取到所资源的线程被称为 Owner；
6) !Owner：当前释放锁的线程。


- Synchronized 实现

1. JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。

2. Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。

3. Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。

4. OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。

5. 处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。

6. Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。

7. 每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的

8. synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。

9. Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。

10. 锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；

11. JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。

- ReentrantLock

ReentrantLock 继承了Lock实现接口定义的方法，是一种可重入锁，除了能完成synchronized所能完成的工作外，还提供了可响应中断锁，可轮询锁请求，定时锁等避免多线程死锁的方法。

Lock接口的主要方法：

1. void lock();执行方法时，如果锁处于空闲状态，当前线程将获取到锁，相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁。

2. boolean tryLock();如果锁可用，则获取锁，并立即返回true，否则返回false，该方法和lock()的区别再有，tryLock()只是试图获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续向下执行。
而lock()方法则一定要获取到锁，如果锁不可用，就一直等待，再未获取到锁之前，当前线程并不继续向下执行。

3. void unlock(); 执行此方法时，当前线程将释放持有的锁，锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常发生。

4. Condition NewCondition() 条件对象，获取等待通知组件，该组件和当前锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将缩放锁。

5. getHoldCount();查询当前线程保持此锁的次数，也是执行此线程执行lock方法的次数。

6. getQueueLength();返回正等待获取此锁的线程估计数，比如启动10个线程，1个线程获得此锁，返回值为9。

7. getWaitQueueLength(Condition);返回等待与此锁相关的给定条件的线程计数，比如启动10个线程，用同一个condition对象，并且此时10个线程都执行了condition对象的await方法，那么此时执行方法返回10.

8. hasWaiters(Condition); 查询释放有线程等待与此锁相关的给定条件condition，对于指定condition对象，有多少线程执行了condition.await方法。

9. hasQueuedThread(Thread thread) 查询给定线程是否等待获取此锁。

10. hasQueuedThreads();是否有线程等待此锁。

11. isFair();是否公平锁。

12. isHeldByCurrentThread();当前线程是否保持锁锁定，线程得执行lock方法得前后分别是false和true。

13. isLock();此锁是否有任意线程占用。

14. lockInterruptibly(); 如果当前线程未被中断，获取锁。

15. tryLock();尝试获得锁，仅在调用锁未被线程占用，获得锁。

16. tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。
