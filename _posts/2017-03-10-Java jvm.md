---
layout: post
title:  "Java JVM相关知识点"
date:   2017-03-10 10:11:03 +0800
categories: Java JVM
tag: Java
---

### 基本概念

JVM是Java Virtual Machine Java虚拟机的缩写，JVM是一种计算机设备的规范，是一个虚构出来的计算机，通过实际计算机上仿真模拟各种计算机功能来实现。

引入Java语言虚拟机后，Java语言在不同平台上运行不需要重新编译。Java语言使用Java虚拟机屏蔽与具体平台相关信息，使Java语言编译只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行。

![JVM概述图](/images/posts/20191216/JVM.jpeg)<br>

### 运行过程

Java源文件，通过编译器产生对应的.class文件，也就是字节码文件，字节码文件通过Java虚拟机解释器，编译成特定机器上的机器码。

1. Java源文件->编译器->字节码文件
2. 字节码文件->JVM->机器码

每个平台的解释器不同，但是实现的虚拟机是相同的，这是Java跨平台的原因。

但一个程序开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。

程序退出或者关闭，虚拟机实例消亡，多个虚拟机实例之间数据不共享。

![JVM图1](/images/posts/20191216/01.png)<br>

#### 线程

线程是指程序执行过程中的操作系统能够运行调度的最小单元。包含在进程之中，是进程的实际运作单位。

JVM 允许一个应用并发执行多个线程。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好后，

就会创建一个操作系统原生线程。Java线程结束，原生线程回收，操作系统负责调度所有线程，把他们分配到任何可用的CPU上。

当原生线程初始化完毕，就会调用Java的run()方法，当线程结束时，会释放原生线程和Java线程的所有资源。

Hotspot Jvm 后台运行的系统线程主要有以下几种：

名称 | 介绍
---- | ----
虚拟机线程（VM thread） | 这个线程等待JVM到达安全点操作出现。这些操作必须再独立线程内执行，因为当堆修改无法进行时，线程都需要JVM位于安全点。操作有stop-the-world垃圾回收、线程栈dump、线程暂停、线程偏向锁解除。
周期性任务线程 | 负责定时器事件（中断），用来调度周期性操作的执行。
GC线程 | 支持JVM中不同的垃圾回收活动。
编译器线程 | 这些线程在运行时将字节码动态编译成本地平台相关机器码。
信号分发线程 | 这个线程接受发送到JVM的信号并调用适当的JVM方法处理。

#### JVM内存区域

![JVM图2](/images/posts/20191216/JVM内存.jpeg)<br>

JVM 内存区域主要分为：

    线程私有区域：
        程序计数器、虚拟机栈、本地方法区。
    线程共享区域：
        Java堆、方法区。
    直接内存
    
线程私有数据区域内生命周期与线程相同，依赖用户线程的启动/结束而创建/销毁。
每个线程都与操作系统本地线程直接映射，因此这部分内存区域与本地线程的启动/结束相对应。

线程共享数据区域内生命周期与JVM的启动/关闭对应创建/销毁。

直接内存不是JVM运行时的内存也不是JVM定义的内存区域，就是堆外单独的一块内存区域。
例如：NIO，基于通道缓冲区结合的I/O方式，可以使用native函数库直接堆外分配内存，通过一个存储在堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中提高性能。

![JVM图3](/images/posts/20191216/02.png)<br>

#### 程序计数器（线程私有）

一块较小的内存空间，是当前线程所执行的字节码行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为线程私有内存。

正在执行Java方法，计数器记录是虚拟机字节码指令的地址。如果还是Native方法为空。

这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域。

#### 虚拟机栈（线程私有）

虚拟机栈遵循LIFO思想（后进先出），虚拟机栈是描述Java方法执行的内存模型，每个方法从执行都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。
每个方法从执行到结束，都对应一个栈帧在虚拟机栈中的入出栈。

栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接（Dynamic Linking）方法返回值和异常分派（Dispatch Exception）。栈帧随着方法调用而创建，
方法结束而销毁，不论方法是正常完成还是异常（抛出异常未被捕获）完成都结束。

![JVM图4](/images/posts/20191216/03.png)<br>

#### 本地方法区（线程私有）

本地方法区和Java Stack作用类似，区别是虚拟机栈为执行Java方法服务，而本地方法栈则为Native方法服务。

在Java代码中被 native 修饰的方法，具体的方法是由Java底层的c/c++实现的。
本地方法栈也是由线程独享的，没有线程安全问题。 例如：
```$xslt
public class Object {

    private static native void registerNatives();
    static {
        registerNatives();
    }

    /**
     * Returns the runtime class of this {@code Object}. The returned
     * {@code Class} object is the object that is locked by {@code
     * static synchronized} methods of the represented class.
     *
     * <p><b>The actual result type is {@code Class<? extends |X|>}
     * where {@code |X|} is the erasure of the static type of the
     * expression on which {@code getClass} is called.</b> For
     * example, no cast is required in this code fragment:</p>
     *
     * <p>
     * {@code Number n = 0;                             }<br>
     * {@code Class<? extends Number> c = n.getClass(); }
     * </p>
     *
     * @return The {@code Class} object that represents the runtime
     *         class of this object.
     * @jls 15.8.2 Class Literals
     */
    public final native Class<?> getClass();

    ......
}
```

#### 堆（线程共享）

堆是被线程共享的一块内存区域，创建的对象和数组都保存在Java堆内存中。
堆也是垃圾收集器进行垃圾收集重要的内存区域。由于现代VM采用分代收集算法，
因此Java堆从GC的角度还可以分为，新生代和老年代。

#### 方法区/永久代（线程共享）

方法区，永久代，存储JVM加载的类信息，常量，静态变量，即时编译器编译后的代码等。

方法区存储的类信息：对每个加载的类型(类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：

* 类型的完整有效名称，全名 包名.类名
* 类型的直接弗雷的完整有效名称（java.lang.object除外，没有声明父类，默认是父类的object）
* 类型的修饰符
* 类型直接接口的有序列表
* 类型的常量池
* 域（Field）信息
* 方法（Method）信息
* 除了常量外的所有静态（static）变量

方法区：static final 修饰的成员变量都存储在方法区中。

方法区存储的静态变量

* 静态变量又称类变量，类中被static修饰的成员变量都是静态变量。静态变量和类关联在一起，随着类的加载存在方法区中而不是在堆中。
* 八种基本数据类型（byte，short，int，long，float，double，char，boolean）静态变量会在方法区开辟空间，并将对应的值存储在方法区。
引用类型的静态变量如果未使用new关键字为引用类型的静态变量分配对象（如：static Object obj;）那么对象的引用obj会存储在方法区中，
并为其指定默认值null;若对于引用类型的静态变量如果用new关键字为引用类型的静态变量分配对象（如：static Person person = new Person()）
那么对象的引用person 会存储在方法区中，并且该对象在堆中的地址也会存储在方法区中（注意此时静态变量只存储了对象的堆地址，而对象本身仍在堆内存中）

方法区存储的方法

* 程序运行时会加载类编译生成的字节码，在这个过程中静态变量和静态方法及普通方法对应的字节码加载到方法区。
* 方法区中没有实例变量，这是因为类加载先与对应类对象的产生，实例变量和对象关联在一起的，没有对象就不存在实例变量，
类加载时没有对象，所以方法区中没有实例变量。
* 静态变量和静态方法及普通方法在方法区存储方式是有区别的。



