---
layout: post
title:  "JVM 类加载机制"
date:   2017-03-13 09:37:09 +0800
categories: Java JVM Class 
tag: Java
---
## JVM 类加载机制

JVM 类加载机制分为五个部分：加载、验证、准备、解析、初始化。

类的生命周期： 加载-> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载 

![JVM 类加载机制](/images/posts/20170312/02.png)<br>

### 加载

加载阶段会在内存中生成一个代表这个类的java.lang.class对象，作为这个类的各种数据的入口。
主要这类不一定非要从Class文件获取，这类可以从包中读取，也可以在运行时计算生成（动态代理），
也可以由其他文件生成（比如JSP文件转换称为对应的Class类）。

### 验证

验证阶段主要目的是为了确保Class文件的字节流中包含信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

### 准备

准备阶段是正式为类变量分配内存并设置类变量的初始阶段，即在方法区中分配这些变量所使用的内存空间。

注意这里所说的初始值概念，比如一个类变量定义为：

    `public static int v = 8080;`
    
实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器<client>方法之中。但是注意如果声明为：

    `public static final int v = 8080;`
    
在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。

### 解析

解析阶段就是指虚拟机将常量池中符号替换为直接引用的过程。符号引用就是class文件中的：CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info等类型的常量。

### 符号引用

符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。

### 直接引用

直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。

### 初始化

初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。

## 类加载

### 类构造器

初始化阶段是执行类构造器client方法的过程，client方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。
虚拟机会保证子client方法执行之前，父类的client方法已执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那编译器可以不为这个类生成client方法。

<label style="color:red">注意以下几种情况不会执行类初始化：</label>
1. 通过子类引用父类的静态字段，只会触发父类的初始化，不会触发子类的初始化。
2. 定义对象数组，不会触发该类的初始化。
3. 常量再编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
4. 通过类名获取Class对象，不会触发类的初始化。
5. 同类Class.forName加载指定类时。，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
6. 通过classLoader默认的loadClass方法，也不会触发初始化动作。


